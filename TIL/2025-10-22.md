# Today I Learning

## 振り返り

今日は、３層スキーマ、主キーや外部キー、正規化の重要性とその方法についての内容を見ました。特に第２正規化と第３正規化について、以前はなかなか理解できなかった部分でしたが、改めて学び直すことで、少しずつ理解できるようになってきました。

## 学んどこと

### どいうふうにデータベースを利用するの？

利用者は**RBDMS**を使ってデータベースからデータを引き出して、結果セット（通常はビューの形）を利用者に返してきます。

RDBMS は**Relational Database Management System**の略です。代表的な RDBMS は、MySQL や PostgreSQL などがあります。

### データベースの種類

- リレーショナルデータベース（RDB）　 → 主流の DB です。
- グラフ型データベース
- キー・バリュー型データベース

### 3 層スキーマ

- 外部スキーマ（ユーザーから見た DB）
- 概念スキーマ（開発者から見た DB）
- 内部スキーマ（DBMS から見た DB）

#### 抱えた疑問（解決済み）

内部スキーマはデータをバイナリや 2 進数の形でコンピュータに保存されているという理解で合っていますか？それでしたら、開発者はあまり触れていないってことですか？
回答：開発者が操作できるのが概念スキーマです。内部スキーマは、データファイルそのもの（データ本体）と思っていればいいです。

### 論理設計

論理設計は、データを管理するためのデータモデル、つまり概念スキーマの設計です。
データ独立性を確保するのに、概念スキーマは絶対に必要です。

### 論理設計の STEP

1. エンティティの抽出
   どんなテーブル（エンティティ）が必要なのかを明確にする。
2. エンティティの定義
   どんなカラム（属性）が必要なのかを明確にする。
3. 正規化
   テーブルを分割することで、データの冗長性をなくす。
4. ER 図の作成
   テーブル間の関係性を視覚的にわかりやすく図を作成する。

### テーブル

#### テーブルの構成

1. 行と列（レコードとカラム）
2. キー
3. 制約

#### 主キー

その値を指定すれば、必ず一行のレコードを特定できる列です。テーブルにおいて必ず一つ存在する必要があり、かつ一つしか存在しないです。

#### 外部キー

リレーショナルデータベースでは、共通の意味を持つカラムを持たせることによって、テーブル間の関係性リレーションを設定できる。

（例）社員テーブルにある部署 ID は外部キーです。もし社員テーブルの部署カラムで、部署に存在しない値を入力すれば、部署は存在しないよというエラーが出ています。それが、**外部キー制約（参照整合性制約）**と呼びます。

社員テーブル

| 社員 ID | 名前 | **部署 ID** |
| :-----: | :--: | :---------: |
|    1    | 佐藤 |      1      |
|    2    | 鈴木 |      3      |
|    3    | 田中 |      2      |

部署テーブル

| 部署 ID | **部署名** |
| :-----: | :--------: |
|    1    |    営業    |
|    2    |    開発    |
|    3    |    経理    |

#### 制約

- 外部キー制約
  - 上記の例を見てみると、存在しない部署のデータを社員テーブルに登録してしまうことを防止できる制約です。
- NOT NULL 制約
  - NULL を禁止する制約です。

### 正規化

データベースにおいて、保持するデータの重複を排除するために、正規化する作業が必要です。
なぜかというと、データの重複（冗長性）があると、無駄なデータ領域と面倒な更新処理を発生してしまうからです。

#### 第 1 正規化　

１つのフィールドには１つの値しか含まないという原則が守られた形です。

#### 第 2 正規化

第 2 正規化は、部分関数従属が解消されていて、完全関数従属のみのテーブルになっている形です。
文字で説明するのは難しいので、例を出して説明します。
現在、社員テーブルがあるとします。

社員テーブル

| 会社 ID | 会社名 | 社員 ID | 名前 | 部署 ID | 部署名 |
| :-----: | :----: | :-----: | :--: | :-----: | :----: |
|    1    | A 銀行 |    1    | 佐藤 |    3    |  経理  |
|    1    | A 銀行 |    2    | 鈴木 |    2    |  開発  |
|    1    | A 銀行 |    3    | 田中 |    1    |  営業  |
|    2    | B 建設 |    1    | 高橋 |    2    |  開発  |
|    2    | B 建設 |    2    | 松本 |    1    |  営業  |
|    2    | B 建設 |    3    | 吉田 |    4    |  人事  |

テーブルを見てみると、主キーは{会社 ID，社員 ID}のことが分かっています。すべてのカラムはこのキーに従属するが、「会社名」列は「会社 ID」列のみに従属しています。
問題点としては、会社名を変更したい場合、複数行の会社名を変更しないといけないことです。大量なレコードがあると、これが非常に時間がかかる作業です。
この問題を解消するには、２つのテーブルに分割する必要があります。

社員テーブル

| 会社 ID | 社員 ID | 名前 | 部署 ID | 部署名 |
| :-----: | :-----: | :--: | :-----: | :----: |
|    1    |    1    | 佐藤 |    3    |  経理  |
|    1    |    2    | 鈴木 |    2    |  開発  |
|    1    |    3    | 田中 |    1    |  営業  |
|    2    |    1    | 高橋 |    2    |  開発  |
|    2    |    2    | 松本 |    1    |  営業  |
|    2    |    3    | 吉田 |    4    |  人事  |

会社テーブル

| 会社 ID | 会社名 |
| :-----: | :----: |
|    1    | A 銀行 |
|    2    | B 建設 |

#### 第 3 正規化

第 3 正規化は、推移的関数従属が解消されている形です。
同じく例を出して説明します。

社員テーブル

| 会社 ID | 社員 ID | 名前 | 部署 ID | 部署名 |
| :-----: | :-----: | :--: | :-----: | :----: |
|    1    |    1    | 佐藤 |    3    |  経理  |
|    1    |    2    | 鈴木 |    2    |  開発  |
|    1    |    3    | 田中 |    1    |  営業  |
|    2    |    1    | 高橋 |    2    |  開発  |
|    2    |    2    | 松本 |    1    |  営業  |
|    2    |    3    | 吉田 |    4    |  人事  |

このテーブルの問題点は、社員がいない部署がテーブルに反映されていないことです。例えば、新しく部署ができました。そうなると、その新しい部署をテーブルに反映できなくなります。
原因として、{部署 ID -> 部署名}　{会社 ID，社員 ID} -> {部署 ID}という２段階の関数従属が成立しているからです。
この問題を解消するには、以下のようにテーブルに分割する必要があります。

社員テーブル

| 会社 ID | 社員 ID | 名前 | 部署 ID |
| :-----: | :-----: | :--: | :-----: |
|    1    |    1    | 佐藤 |    3    |
|    1    |    2    | 鈴木 |    2    |
|    1    |    3    | 田中 |    1    |
|    2    |    1    | 高橋 |    2    |
|    2    |    2    | 松本 |    1    |
|    2    |    3    | 吉田 |    4    |

会社テーブル

| 会社 ID | 会社名 |
| :-----: | :----: |
|    1    | A 銀行 |
|    2    | B 建設 |

部署テーブル

| 部署 ID | 部署名 |
| :-----: | :----: |
|    1    |  営業  |
|    2    |  開発  |
|    3    |  経理  |
|    4    |  人事  |
|    5    |  総務  |

#### その他

正規化したテーブルは JOIN による結合で正規化の前の状態に戻せます。これに関して、具体的にどのように戻せるのか、まだわからないですが、課題として、今後は学ぶ予定です。